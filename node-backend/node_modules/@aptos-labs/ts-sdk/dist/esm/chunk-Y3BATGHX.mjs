import{a as K,b as S}from"./chunk-O2BPA6TS.mjs";import{d as h}from"./chunk-KUZ2YTJH.mjs";import{a,b as c}from"./chunk-GMBSQDPO.mjs";import{i as m,j as g,k as P,n as w}from"./chunk-G5XLMQ5E.mjs";import{b as d}from"./chunk-OHRL766V.mjs";import{a as s}from"./chunk-A63SMUOU.mjs";import{b as f}from"./chunk-BCUSI3N6.mjs";import{d as y}from"./chunk-UAL27G6B.mjs";import v from"eventemitter3";var o=class o extends s{constructor(e){super();let{address:r,ephemeralKeyPair:t,uidKey:i,uidVal:E,aud:b,pepper:A,proof:n,proofFetchCallback:l,jwt:x}=e;if(this.ephemeralKeyPair=t,this.publicKey=m.create(e),this.accountAddress=r?d.from(r):this.publicKey.authKey().derivedAddress(),this.uidKey=i,this.uidVal=E,this.aud=b,this.jwt=x,this.emitter=new v,this.proofOrPromise=n,n instanceof w)this.proof=n;else{if(l===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async T=>{await l(T),this.emitter.removeAllListeners()}),this.init(n)}this.signingScheme=2;let u=f.fromHexInput(A).toUint8Array();if(u.length!==o.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${o.PEPPER_LENGTH}`);this.pepper=u}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(r){r instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:r.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Cannot serialize - proof undefined");this.proof.serialize(e)}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let r=new c(this.sign(e)),t=new a(this.publicKey);return new h(t,r)}signTransactionWithAuthenticator(e){let r=new c(this.signTransaction(e)),t=new a(this.publicKey);return new h(t,r)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}sign(e){let{expiryDateSecs:r}=this.ephemeralKeyPair;if(this.isExpired())throw new Error("EphemeralKeyPair is expired");if(this.proof===void 0)throw new Error("Proof not found - make sure to call `await account.waitForProofFetch()` before signing.");let t=this.ephemeralKeyPair.getPublicKey(),i=this.ephemeralKeyPair.sign(e);return new g({jwtHeader:y(this.jwt.split(".")[0]),ephemeralCertificate:new P(this.proof,0),expiryDateSecs:r,ephemeralPublicKey:t,ephemeralSignature:i})}signTransaction(e){if(this.proof===void 0)throw new Error("Proof not found - make sure to call `await account.waitForProofFetch()` before signing.");let r=K(e),i=new p(r,this.proof.proof).hash();return this.sign(i)}verifySignature(e){let{message:r,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:r,signature:t.ephemeralSignature}))}};o.PEPPER_LENGTH=31;var F=o,p=class extends s{constructor(r,t){super();this.domainSeparator="APTOS::TransactionAndProof";this.transaction=r,this.proof=t}serialize(r){r.serializeFixedBytes(this.transaction.bcsToBytes()),r.serializeOption(this.proof)}hash(){return S(this.bcsToBytes(),this.domainSeparator)}};export{F as a,p as b};
//# sourceMappingURL=chunk-Y3BATGHX.mjs.map